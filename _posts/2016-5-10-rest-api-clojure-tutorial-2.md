---
layout: post
title: Liberator + Clojure REST API, First approach - Part 2
---

In [the first part](http://enyert.github.io/rest-api-clojure-tutorial/) of this approach, we started a clojure project with *lein compojure* template and we
made some modifications on *project.cl* file.

In this post, I'll explain every part of our project with more details.

### Models

In this folder, we have a namespace called db. This namespace contains the basic
database configuration, some utility functions and the basic database operations
to be used with our entities.

##### Utility functions

```clojure
;; Utility operations

(defn get-environment-var
  "Get the value of an environment variable"
  [name]
  (System/getenv name))

(defn convert-dates
  "Convert dates from miliseconds to java.sql.Timestamp object"
  [date1 date2]
  (hash-map
   :starting_date (java.sql.Timestamp. date1)
   :ending_date (java.sql.Timestamp. date2)))

(defn process-promotion
  "Merge a promotion map with new dates from convert-dates function"
  [promotion]
  (merge promotion
    (convert-dates (:starting_date promotion) (:ending_date promotion))))
```
As you can see, this code snippet contains 3 functions: *get-environment-var,
convert-dates* and *process-promotion.*

**get-environment-var** function is used to get the value of an environment
variable with a given name(I know this is just one single line, but the
function name is easy to remember).

**convert-dates** converts two dates in milliseconds [date1 date2] into a map
with the following structure:

```clojure
{:starting_date java.sql.Timestamp. date1
 :ending_date java.sql.Timestamp. date2}
```
**process-promotion** merges our promotion value taken from the request with the
map generated by *convert-dates*. This function simplifies the interaction with
jdbc.

##### Basic database configuration data

```clojure
;; Database configuration data

(def db {:subprotocol "postgresql"
         :subname (get-environment-var "CLOJUCHIPS_DB_URL")
         :user (get-environment-var "CLOJUCHIPS_DB_USER")
         :password (get-environment-var "CLOJUCHIPS_DB_PASS")})
```
Here we defined a value named db with the basic information about the database.
Note that we are not exposing via hard-code our database information, instead
we read our database parameters from the environment variables created in the
[previous post](http://enyert.github.io/rest-api-clojure-tutorial/).  

##### Generic operations

We have defined our basic operations for our entities: get all entities, get,
update, create and delete an entity. So, for DRY principle we have these five
generic operations in our *db.clj* too.

```clojure
;; Generic operations

(defn read-all-items
  "Read all rows from any given entity"
  [table]
  (sql/query db [(str "select * from " table)]))

(defn read-one-item
  "Read an entity with an id provided by the client"
  [table id]
  (first (sql/query db [(str "select * from " table " where id=" id)])))

(defn create-one-item
  "Create an entity using json format"
  [table item]
  (if (= table "promotion")
   (sql/insert! db (keyword table) (process-promotion (parse-string (str item) true)))
   (sql/insert! db (keyword table) (parse-string (str item) true))))

(defn update-item
  "Update an item with an id provided by the client"
  [id table item]
  (if (= table "promotion")
    (sql/update!
     db
     (keyword table)
     (process-promotion (parse-string (str item) true))
     [(str "id=" id)])
    (sql/update! db (keyword table) (parse-string (str item) true) [(str "id=" id)])))

(defn delete-item
  "Delete an item with an id provided by the client"
  [table id]
  (sql/delete! db (keyword table) [(str "id=" id)]))  
```

##### Entity specific operations

Fine, we have our "generic operations" but we need to specify these functions
with our specific entities, *products* and *promotions* in this case.

```clojure
;; Product operations

(defn read-all-products []
  (read-all-items "product"))

(defn read-one-product [id]
  (read-one-item "product" id))

(defn update-product [id item]
  (update-item id "product" item))

(defn create-product [item]
  (create-one-item "product" item))

(defn delete-product [id]
  (delete-item "product" id))


;; Promotion operations

(defn read-all-promotions []
  (read-all-items "promotion"))

(defn read-one-promotion [id]
  (read-one-item "promotion" id))

(defn update-promotion [id item]
  (update-item id "promotion" item))

(defn create-promotion [item]
  (create-one-item "promotion" item))

(defn delete-promotion [id]
  (delete-item "promotion" id))
```


### Resources(Liberator)



### Routes

### Firing up!

### Final thoughts
